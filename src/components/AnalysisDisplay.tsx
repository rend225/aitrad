import React, { useState } from 'react';
import { useAuth } from '../hooks/useAuth';
import { 
  Copy, 
  Check, 
  Send, 
  TrendingUp, 
  TrendingDown, 
  Minus, 
  Target,
  BarChart3,
  Clock,
  Percent,
  AlertTriangle,
  Crown,
  Settings,
  ExternalLink,
  MessageSquare,
  FileText,
  Activity,
  Zap,
  DollarSign,
  Shield
} from 'lucide-react'; 

interface AnalysisDisplayProps {
  analysis: string;
  prompt?: string;
  signal?: {
    pair: string;
    type: 'buy' | 'sell' | 'hold';
    entry?: number;
    stopLoss?: number;
    takeProfit1?: number;
    takeProfit2?: number;
    probability?: number;
  };
  school: string;
  timestamp?: Date;
  onSendToTelegram?: (message: string) => Promise<void>;
}

const AnalysisDisplay: React.FC<AnalysisDisplayProps> = ({
  analysis,
  prompt,
  signal,
  school,
  timestamp,
  onSendToTelegram
}) => {
  const { user } = useAuth();
  const [copied, setCopied] = useState(false);
  const [copiedPrompt, setCopiedPrompt] = useState(false);
  const [sendingToTelegram, setSendingToTelegram] = useState(false);
  const [telegramSent, setTelegramSent] = useState(false);

  const getSignalTypeIcon = (type: string) => {
    switch (type) {
      case 'buy': return <TrendingUp className="h-5 w-5 text-green-400" />;
      case 'sell': return <TrendingDown className="h-5 w-5 text-red-400" />;
      case 'hold': return <Minus className="h-5 w-5 text-yellow-400" />;
      default: return <Target className="h-5 w-5 text-blue-400" />;
    }
  };

  const getSignalTypeColor = (type: string) => {
    switch (type) {
      case 'buy': return 'text-green-400 bg-green-400/10 border-green-400/20';
      case 'sell': return 'text-red-400 bg-red-400/10 border-red-400/20';
      case 'hold': return 'text-yellow-400 bg-yellow-400/10 border-yellow-400/20';
      default: return 'text-blue-400 bg-blue-400/10 border-blue-400/20';
    }
  };

  const formatAnalysisForDisplay = (text: string) => {
    // Split analysis into sections for better readability
    const sections = text.split(/\n\n+/);
    
    // Function to check if a section is about ICT Smart Money Logic
    const isICTSection = (text: string) => {
      return text.toLowerCase().includes('ict smart money') || 
             text.toLowerCase().includes('smart money logic') ||
             text.toLowerCase().includes('institutional order flow');
    };

    // Function to check if a section is about Invalidation criteria
    const isInvalidationSection = (text: string) => {
      return text.toLowerCase().includes('invalidation') || 
             text.toLowerCase().includes('no-trade criteria');
    };

    // If there's no text, show a placeholder
    if (!text || text.trim() === '') {
      return (
        <div className="text-gray-400 italic">
          No analysis available. Generate a new signal to see results.
        </div>
      );
    }

    return sections.map((section, index) => {
      // Check if section is a header
      const isHeader = /^(SIGNAL SUMMARY|MARKET ANALYSIS|RECOMMENDATION|CONCLUSION|RISK ASSESSMENT|TECHNICAL ANALYSIS|FUNDAMENTAL ANALYSIS|MULTI-TIMEFRAME CONTEXT|EXECUTION TIMEFRAMES|TRADE SETUP|JUSTIFICATION|INVALIDATION|MARKET STRUCTURE|ICT SMART MONEY|SMART MONEY LOGIC):/i.test(section);
      
      if (isHeader) {
        const [title, ...content] = section.split(':');
        return formatSectionTitle(title, content.join(':'));
      }
      
      // Handle other section types
      if (isICTSection(section)) {
        return formatICTSection(section, index);
      }
      
      if (isInvalidationSection(section)) {
        return formatInvalidationSection(section, index);
      }
      
      // Default formatting for other sections
      return formatDefaultSection(section, index);
    });
  };

  const formatTelegramMessage = () => {
    const timestamp = new Date().toLocaleString();
    let message = `🤖 *AI Trading Signal*\n\n`;
    
    if (signal) {
      const typeEmoji = signal.type === 'buy' ? '🟢' : signal.type === 'sell' ? '🔴' : '🟡';
      message += `${typeEmoji} *${signal.type.toUpperCase()}* ${signal.pair}\n\n`;
      
      if (signal.entry) message += `📍 *Entry:* ${signal.entry}\n`;
      if (signal.stopLoss) message += `🛑 *Stop Loss:* ${signal.stopLoss}\n`;
      if (signal.takeProfit1) message += `🎯 *TP1:* ${signal.takeProfit1}\n`;
      if (signal.takeProfit2) message += `🎯 *TP2:* ${signal.takeProfit2}\n`;
      if (signal.probability) message += `📊 *Probability:* ${signal.probability}%\n`;
      
      message += `\n📚 *Analysis Method:* ${school}\n`;
      message += `⏰ *Generated:* ${timestamp}\n\n`;
    }
    
    message += `📋 *Full Analysis:*\n${analysis.replace(/\*\*/g, '*')}\n\n`;
    message += `⚠️ *Risk Warning:* Trading involves substantial risk. This is for educational purposes only.\n\n`;
    message += `🔗 Generated by AI Trader Platform`;
    
    return message;
  };

  const copyToClipboard = async () => {
    try {
      const fullText = `AI Trading Analysis - ${timestamp?.toLocaleString() || new Date().toLocaleString()}\n\n` +
        `Trading Pair: ${signal?.pair || 'N/A'}\n` +
        `Signal Type: ${signal?.type?.toUpperCase() || 'N/A'}\n` +
        `School: ${school}\n\n` +
        (signal ? `SIGNAL DETAILS:\n` +
          `Entry: ${signal.entry || 'N/A'}\n` +
          `Stop Loss: ${signal.stopLoss || 'N/A'}\n` +
          `Take Profit 1: ${signal.takeProfit1 || 'N/A'}\n` +
          `Take Profit 2: ${signal.takeProfit2 || 'N/A'}\n` +
          `Probability: ${signal.probability || 'N/A'}%\n\n` : '') +
        `FULL ANALYSIS:\n${analysis}\n\n` +
        `Generated by AI Trader Platform`;
      
      await navigator.clipboard.writeText(fullText);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
    }
  };

  const copyPromptToClipboard = async () => {
    if (!prompt) return;
    try {
      await navigator.clipboard.writeText(prompt);
      setCopiedPrompt(true);
      setTimeout(() => setCopiedPrompt(false), 2000);
    } catch (error) {
      console.error('Failed to copy prompt:', error);
    }
  };

  const sendToTelegram = async () => {
    if (!onSendToTelegram) return;
    
    setSendingToTelegram(true);
    try {
      const message = formatTelegramMessage();
      await onSendToTelegram(message);
      setTelegramSent(true);
      setTimeout(() => setTelegramSent(false), 3000);
    } catch (error) {
      console.error('Failed to send to Telegram:', error);
    } finally {
      setSendingToTelegram(false);
    }
  };

  const calculateRiskReward = () => {
    if (!signal?.entry || !signal?.stopLoss || !signal?.takeProfit1) return null;
    
    const risk = Math.abs(signal.entry - signal.stopLoss);
    const reward = Math.abs(signal.takeProfit1 - signal.entry);
    const ratio = reward / risk;
    
    return {
      risk: risk.toFixed(2),
      reward: reward.toFixed(2),
      ratio: ratio.toFixed(2)
    };
  };

  const riskReward = calculateRiskReward();

  return (
    <div className="space-y-6 md:space-y-8">
      {/* Rest of the component implementation... */}
    </div>
  );
};

export default AnalysisDisplay;